/** cf01.h

This file is C++ source code for including C-flat features into a C++ program


Copyright (c) 2021 Mac Stevens <stevensm@earthlink.net> <www.macstevens.net>

Permission to use, copy, modify, and distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

Reference: https://opensource.org/licenses/ISC
*/

#ifndef CF01_H
#define CF01_H

#include <iostream>
#include <assert.h>
#include <stdio.h>
#include <string>



/* call at beginning of function */
#define CF01_AA_INCR_CALL_DEPTH() \
    {cf01_auto_assert_wksp::get_instance()->incr_call_depth();}

/* call at end of function */
#define CF01_AA_DECR_CALL_DEPTH() \
    {cf01_auto_assert_wksp::get_instance()->decr_call_depth();}

/* Place CF01_AUTO_ASSERT(_condition) wherever an invariant function
  would go.
_condition - boolean value or function.  TRUE=> data is ok, FALSE=>some error
*/
#define CF01_AUTO_ASSERT( _condition ) {                                   \
    cf01_auto_assert_wksp::get_instance()->incr_p_count();                 \
    if (cf01_auto_assert_wksp::get_instance()->should_run_aasrt()){        \
        bool _result = (_condition);                                       \
        cf01_auto_assert_wksp::get_instance()->report_aasrt_result(        \
            _result, __FILE__, __LINE__, __FUNCTION__, #_condition );      \
        }                                                                  \
    }

/* true => should run extra debug code */
#define CF01_AA_SHOULD_RUN_XDBG( _dbg_lvl ) \
    (cf01_auto_assert_wksp::get_instance()->should_run_xdbg(_dbg_lvl))

/* run extra debug assertion, if debug level meets criteria */
#define CF01_AA_XDBG_ASSERT( _condition, _dbg_lvl ){                    \
    if(CF01_AA_SHOULD_RUN_XDBG(_dbg_lvl)){                              \
        bool _result = (_condition);                                    \
        cf01_auto_assert_wksp::get_instance()->report_aasrt_result(     \
            _result, __FILE__, __LINE__, __FUNCTION__, #_condition);    \
        }                                                               \
    }

#define CF01_AA_ERR_BUF() \
    (cf01_auto_assert_wksp::get_instance()->get_utility_err_buf())

#define CF01_AA_ERR_BUF_CAPACITY() \
    (cf01_auto_assert_wksp::get_instance()->get_utility_err_buf_capacity())

#define CF01_AA_ERR_BUF_POS_PTR() \
    (cf01_auto_assert_wksp::get_instance()->get_utility_err_buf_pos_ptr())

#define CF01_AA_WKSP_OUTPUT( _os ) \
    (cf01_auto_assert_wksp::get_instance()->ostream_output(_os))



/* todo: replace with std::uint64_t,etc. from <cstdint>. */
typedef char cf01_int8;
typedef unsigned char cf01_uint8;
typedef short cf01_int16;
typedef unsigned short cf01_uint16;
typedef long cf01_int32;
typedef unsigned long cf01_uint32;
typedef long long cf01_int64;
typedef unsigned long long cf01_uint64;
typedef double cf01_float64;



/* debug levels
  level 0 => code is always executed
  level 1 => 10% of the code can be run without hampering run time too much
  level 2 => 1%
  level 3 => 0.1%
*/
enum cf01_aa_debug_level {
    CF01_AA_DEBUG_LEVEL_0 = 0,
    CF01_AA_DEBUG_LEVEL_1 = 1,
    CF01_AA_DEBUG_LEVEL_2 = 2,
    CF01_AA_DEBUG_LEVEL_3 = 3
    };

/* at a given call index range and given depth range, criteria:
run invariant when (call_idx % div) == mod */
struct cf01_call_idx_range_crit
{
public:
    cf01_uint64    m_call_idx_range_end; /* (range max value) + 1 */
    cf01_uint64    m_call_idx_div; /* divisor */
    cf01_uint64    m_call_idx_mod; /* remainder */
};



#define CF01_AASRT_CALL_DEPTH_COUNT (32)
#define CF01_AASRT_CALL_IDX_RANGE_COUNT (16)

/* auto-assert assertion result */
struct cf01_aasrt_result
{
public:
    /* true => assertion was executed */
    bool m_done;

    /* true => assertion passed */
    bool m_pass;

    /* name of source code file where assertion was called */
    std::string m_file_name;

    /* name of function where assertion was called */
    std::string m_func_name;

    /* line of file where assertion was called */
    int m_line_num;

    /* call depth when assertion was executed */
    cf01_uint8 m_call_depth; 

    /* total number of standard (not extra debug) auto-assertions
    ("points") either skipped or executed at given depth.
    This includes the assertion whose result this struct represents. */
    cf01_uint64 m_aasrt_p_count[CF01_AASRT_CALL_DEPTH_COUNT]; 

    /* transition count for each call depth, when assertion was executed */
    cf01_uint64 m_curr_t_count[CF01_AASRT_CALL_DEPTH_COUNT];

    /* error message generated by assertion */
    std::string m_err_msg;

public:
    cf01_aasrt_result();
   ~cf01_aasrt_result();
};


/* todo: future improvements:
    distinguish between 1) an assertion that checks a subset of conditions and
    2) an assertion that is equivalent to a comprehensive set of checks (invariant)  */
class cf01_auto_assert_wksp
{
private:
    /* current status */

    /* current call depth */
    cf01_uint8 m_call_depth; 

    /* total number of standard (not extra debug) assertions ("points")
    reached at each depth.
    This includes all those assertions that were either skipped or executed
    plus, if any, the current assertion which is about to be skipped or
    executed or is currently being skipped or executed. */
    cf01_uint64 m_curr_p_count[CF01_AASRT_CALL_DEPTH_COUNT]; 

    /* transition is the action of incrementing call depth */
    /*current transition count for each call depth 

    for each call depth, the number of transitions down
    to that depth.  i.e., the number of function calls
    resulting in going down to that depth */
    cf01_uint64 m_curr_t_count[CF01_AASRT_CALL_DEPTH_COUNT]; 

    /* A: Standard Assertions

    These are assertions that are executed on a fixed schedule, regardless
    of debug level */

    /* control criteria, determining whether to run standard (non extra debug) 
    auto assertion */
    cf01_call_idx_range_crit m_depth_call_idx_range_crit
                               [CF01_AASRT_CALL_DEPTH_COUNT]
                               [CF01_AASRT_CALL_IDX_RANGE_COUNT];

    /* for each call depth d, the index i for m_depth_call_idx_range_crit[d][i]
    specifying the current control criteria that should be used */
    cf01_uint8 m_idx_crit_idx[CF01_AASRT_CALL_DEPTH_COUNT]; 



    /* B: extra debug assertions and supporting code 

    These are assertions and supporting code that are only executed if
    the debug level is high enough according to the following if statement:

    if( m_curr_t_count[m_call_depth] >= m_xdbg_ctrl_t_count[m_call_depth]
        && dbg_lvl <= m_xdbg_ctrl_dbg_lvl[m_call_depth] )
        {
        should execute extra debug assertion or code.
        } 
    */

    /* controls when extra debug code and assertions will be executed.
    This is the minimum total transition count at each call depth.
    If total transition count is below this value, then no extra debug
    code or assertions are run.  If total transition count is at or above
    this value, then extra debug code with debug level at or below
     m_xdbg_ctrl_dbg_lvl[d] is run. */
    cf01_uint64 m_xdbg_ctrl_t_count[CF01_AASRT_CALL_DEPTH_COUNT];

    /* controls when extra debug code and assertions will be executed.
    Extra debug code and assertions with debug level at or below
    m_xdbg_ctrl_dbg_lvl[d] will be executed when transition count is at or 
    above m_xdbg_ctrl_t_count[d] */
    cf01_uint8 m_xdbg_ctrl_dbg_lvl[CF01_AASRT_CALL_DEPTH_COUNT]; 

    /* info for last assertion that was run and passed */
    cf01_aasrt_result m_aasrt_result_last_passed;

    /* info for first assertion that failed */
    cf01_aasrt_result m_aasrt_result_first_failed;

    /* utility buffer */
    #define CF01_AA_UTILITY_ERR_BUF_CAPACITY (2047)
    char m_utility_err_buf[CF01_AA_UTILITY_ERR_BUF_CAPACITY];
    size_t m_utility_err_buf_pos;

    static cf01_auto_assert_wksp m_instance; /* singleton */

public:
    static cf01_auto_assert_wksp *get_instance() { return &m_instance; }

    cf01_auto_assert_wksp();
   ~cf01_auto_assert_wksp();

    /* initialize */
    void init_default();
    void init_from_journal_file();
    void add_aasrt_call_idx_range_crit( const cf01_uint8& depth,
        const cf01_call_idx_range_crit* idx_range_crit, bool *result,
        std::string *err_str );
    void complete_table();

    /* initialize with default values */
    /* initialize from journal file */
    /* save m_aasrt_result_first_failed to journal file */
    /* save m_aasrt_result_last_passed to journal file*/


    /* Increment call depth. call at beginning of function */
    void incr_call_depth() {
        m_call_depth = (m_call_depth < (CF01_AASRT_CALL_DEPTH_COUNT-1)) ?
    		m_call_depth + 1 : (CF01_AASRT_CALL_DEPTH_COUNT-1);
        ++(m_curr_t_count[m_call_depth]); }

    /* Decrement call depth. call at end of function */
    void decr_call_depth() {
        m_call_depth = (m_call_depth > 0) ? m_call_depth - 1 : 0; }

    void incr_p_count();
    bool should_run_aasrt() const;
    bool should_run_xdbg(const cf01_uint8& dbg_lvl) const;
    void report_aasrt_result( const bool result, const char *file_name,
        const int line_num, const char *function, const char *condition_str);

    /* utility buffer */
    char *get_utility_err_buf() { return &(m_utility_err_buf[0]); }
    size_t get_utility_err_buf_capacity() const {
        return CF01_AA_UTILITY_ERR_BUF_CAPACITY; }
    size_t *get_utility_err_buf_pos_ptr() { return &m_utility_err_buf_pos; }
    void clear_utility_err_buf() {
        m_utility_err_buf_pos=0; m_utility_err_buf[0]=0x0; }

    int verify_data( std::string *err_str ) const;
    std::ostream& ostream_output(std::ostream& os) const;

private:
    void save_aasrt_result_to_file(const cf01_aasrt_result *r);
};













#endif /* CF01_H */
